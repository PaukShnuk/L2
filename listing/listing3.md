Что выведет программа? Объяснить вывод программы. Объяснить внутреннее
устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main
import (
	"fmt"
	"os"
)
func Foo() error {
	var err *os.PathError = nil
	return err
}
func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```

Ответ:
```
<nil>
false

    Интерфейс под капотом хранит указатель на структуру-таблицу, которая хранит некоторые 
метаданные о типе и список методов, используемых для удовлетворения интерфейса, а также
указатель на фактическую переменную с конкретным (статическим) типом. 
    Поскольку эта структура-таблица будет уникальна для каждой пары интерфейс-статический 
тип, то просчитывать её на этапе компиляции будет нерационально и неэффективно. Вместо этого, 
компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, 
хранится список методов, реализованных для данного типа. Аналогично генерируются метаданные 
со списком методов для каждого интерфейса.
    
    Пустому интерфейсу удовлетворяет вообще любой тип. Поскольку у пустого интерфейса нет 
никаких методов, то и структуру-таблицу для него просчитывать и хранить не нужно — 
достаточно только метаинформации о статическом типе. То есть пустой интерфейс хранит 
указатель на объект статического типа и метадные о типе все. (нет указателя на таблицу).

    В нашей программе os.PathError - тип данных, реализующий интерфейс error. Из функции
также возвращается error. Значение интерфеса состоит из конкретного значения (что он что-то 
хранит - объект удовлетворябщего типа) и динамического значения (по сути значение объекта
который храним). Таким образом, в err типа error только динамическое значение будет равно nil,
а статическое значение будет равно типу PathErr. С nil в нашем случае сравнивается не только
значение объекта, но и сам тип объекта. Первый принт выведет динамическиое значение, nil, а
второй false, поскольку err !=[nil,nil]